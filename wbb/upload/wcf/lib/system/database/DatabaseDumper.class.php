<?php
require_once(WCF_DIR.'lib/system/io/File.class.php');
require_once(WCF_DIR.'lib/system/io/ZipFile.class.php');

/**
 * This class exports or imports database data (the structure of tables and table content (rows)).
 *
 * @author	Benjamin Kunz
 * @copyright	2001-2009 WoltLab GmbH
 * @license	WoltLab Burning Board License <http://www.woltlab.com/products/burning_board/license.php>
 * @package	com.woltlab.wcf.acp.system.db
 * @subpackage	system.database
 * @category 	Community Framework (commercial)
 */
class DatabaseDumper {
	/**
	 *  Function exports the active database
	 * @param 	 		$file
	 * @param 	array 		$tables 			export tables 
	 * @param 	int 		$limit 				maximum db operations per loop
	 * @param 	int 		$loopTimeLimit 		maximum time per loop
	 * @param 	int 		$loopStart
	 * @param 	int 		$offset 			filepointer offset
	 * @param 	string 		$tableName 			name of last used table
	 */
	public static function export($file, $tables, $limit, $loopTimeLimit, $loopStart, $offset, $tableName) {
		// first loop. open file
		if ($offset == -1) {
			// write header info
			$head = "-- WoltLab Community Framework\n";
			$head .= "-- database: ".WCF::getDB()->getDatabaseName()."\n";
			$head .= "-- generated at ".date('r')."\n\n";
			$head .= "-- DO NOT EDIT THIS FILE\n\n";
			$head .= "-- WCF DATABASE CHARSET\n";
			$head .= "SET NAMES  ".WCF::getDB()->getCharset().";\n\n";
			$file->write($head);
			$file->close();

			return array(
				'tableName' => '', 
				'offset' => 0, 
				'completedTables' => array(),
				'done' => 0,
				'resetLimit' => false
			);
		}
		// following loops. write export data (structure and records)
		// TODO: check if filesize is over 2GB and split data to more files if so
		else if (!empty($tables)) {
			// get the export tables 
			$exportTables = self::getTableStates($tables);
			$completedTables = array();
			$i = 0;
			$resetLimit = false;
			
			// write each table and his data to the backupfile
			foreach ($exportTables as $table) {
				$tableName = $table['Name'];
				$resetLimit = false;
				
				if ($i < $limit && time() < ($loopStart + $loopTimeLimit)) {
					// get table structure
					$sql = 'SHOW CREATE TABLE `'.$tableName.'`';
					$result = WCF::getDB()->sendQuery($sql);
					$firstRow = WCF::getDB()->fetchArray($result);
					if ($offset == 0) { 
						$file->write("-- Create Table ".$tableName."\n");
						$file->write("DROP TABLE IF EXISTS `".$tableName."`;\n");
						$file->write($firstRow['Create Table'].";\n\n");
					}

					// build columntype array
					preg_match("%CREATE TABLE `".$tableName."` \((.*?)\)[^)]+;$%is", $firstRow['Create Table'].";", $match);
					preg_match_all("%`(\w*?)` (\w+).*,?\n%", $match[1], $columns);
					$columnTypes = array();
					foreach ($columns[1] as $key => $column) {
						if (preg_match("%int%i",$columns[2][$key])) { 
							$columnTypes[$column] = 0;
						}
						else  $columnTypes[$column] = 1;
					}

					// get table data
					$sql = 'SELECT * FROM `'.$tableName.'`';
					$tmpOffset = $offset;

					$result = WCF::getDB()->sendQuery($sql, $limit - 1, $offset);
					$insertExist = false;
					while ($row = WCF::getDB()->fetchArray($result)) {
						if ($i < $limit && time() < ($loopStart + $loopTimeLimit)) {
							if (!$insertExist && $offset == 0) {
								$file->write("-- Data for table ".$tableName."\n");		
							} 
							
							// escape string columns. quote string and empty columns  
							foreach ($row as $columnName => $columnValue) {
								// column type value is a string 
								if ($columnTypes[$columnName]) {
									$row[$columnName] = "'".escapeString($columnValue)."'";
								}
								else if (empty($columnValue) && !is_numeric($columnValue)) {
									$row[$columnName] = "''";
								}							
							}
							
							// write row
							if (!$insertExist && $offset == 0) {
								$file->write("INSERT INTO `".$tableName."` VALUES (".implode(",", $row).")");
							}
							else {
								$file->write(",\n(".implode(",", $row).")");
							}
							$i++;
							$insertExist = true;
							$offset++;
						}
						// max limit or timelimit reached
						else break 2;
					}
					
					// check if last written data record is the last from table
					$sql = 'SELECT COUNT(*) AS count FROM `'.$tableName.'`';
					$firstRow = WCF::getDB()->getFirstRow($sql);
					// table ready
					 
					if ($firstRow['count'] <= ($tmpOffset + $limit - 1)) {
						if ($insertExist) $file->write(";\n\n");
						// mark table as complete 
						$i++;
						$completedTables[] = $tableName;
						$offset = 0;
					}
					// get more data in nect loop
					else break;
					
					$resetLimit = true;;
				}
				// max limit or timelimit reached
				else break;
			}
			$file->close();
			
			return array(	
				'tableName' => $tableName, 
				'offset' => $offset, 
				'completedTables' => $completedTables,
				'done' => $i,
				'resetLimit' => $resetLimit
			);		
		}
		else {
			return array(
				'tableName' => '', 
				'offset' => 0, 
				'completedTables' => array(),
				'done' => $limit,
				'resetLimit' => false
			);
		}
	}
	
 	/**
	 *  Function imports a sql file into active database (gzipped or not)
	 * @param 	 		$file				file containing sql commands
	 * @param 	int 		$loopTimeLimit 			maximum time per loop
	 * @param 	int 		$loopStart			timestamp of loop-start
	 * @param 	int 		$offset 			filepointer offset
	 * @param 	string 		$extendedCommand 		command head
	 * @param 	boolean 	$ignoreErrors 			break after error or ignore errors 
	 */
	public static function import($file, $filesize, $isGzip, $loopTimeLimit, $loopStart, $offset, $charset, $extendedCommand = '', $ignoreErrors = false) {
		// jump to last quitting point	
		$file->seek($offset);
		
		// init vars
		$commandOffset = $commandCount = 0;
		$previousC = $query = '';
		$isInsideComment = $isSingleLineComment = $isMultilineComment = false; 
		$isInsideString = $isInsideCommand = $isSpecialCommand = false;
		$checkExtendedCommand = $isExtendedCommand = false;
		$checkReplaceCommand = $execute = false;
		$firstByte = intval(0xEF);
		$secondByte = intval(0xBB);
		$thirdByte = intval(0xBF);
		$bomOffset = 0; 
		$errors = array('messages' => array(), 'errorDescriptions' => array());
		
		// check if the first three bytes are the utf-8 bom  
		if ($offset == 0) {
			$firstC = unpack('C*', $file->getc());
			if ($firstC[1] == $firstByte) {
				$secondC = unpack('C*', $file->getc());
				if ($secondC[1] == $secondByte) {
					$thirdC = unpack('C*', $file->getc());
					// found bom. begin after it.
					if ($thirdC[1] == $thirdByte) {
						$offset = $bomOffset = 3;				
					}	
				}
			}
			// no bom. jump to file start
			$file->seek(0);
		}
		
		if (!empty($extendedCommand)) $isExtendedCommand = $isInsideCommand = $isSpecialCommand = true;
		
		// set database connection to the charset of the backupfile
		if (!empty($charset)) WCF::getDB()->setCharset($charset);

		// read characters up to $timeLimit. execute each complete command 
		// if not (probably most cases) rewind the file pointer to the start of the command fragment		
		while ((false !== ($c = $file->getc())) && ((time() - $loopStart < $loopTimeLimit)) || $commandCount == 0 || $execute) {
			// search for string end: '
			if ($isInsideString) {
				$query .= $c;
				$nextC = '';
				if ($c == "'" && $previousC != "\\") {
					if (false !== ($nextC = $file->getc()) && $nextC != "'") {
						$file->seek($file->tell() - 1);
						$isInsideString = false;
					}
					else $query .= "'";					
				}
				else if ($c == "'") {
					$isInsideString = self::checkEscapedQuote($file);
				}
			}
			// search for comment end: newline or */
			else if ($isInsideComment) {
				if ($isSingleLineComment && preg_match('/(\n|\r)/', $c, $match)) {
					// if windows newline get nect char too
					if (preg_match('/\r/', $c)) {
						$nextC = $file->getc();
						if (!preg_match('/\n/', $nextC)) {
							$file->seek($file->tell() - 1);
						}
					}
					$isInsideComment = $isSingleLineComment = false;
				}
				else if ($isMultilineComment && $previousC.$c == "*/") {
					$isInsideComment = $isMultilineComment = false;
				}
			}
			// execute a sql statement
			else if ($execute) {
				$execute = false;

				// don't do something with wcf#_acp_session table from active wcf
				if (!preg_match("/(DROP|CREATE|ALTER|RENAME|INSERT|REPLACE|UPDATE|DELETE|TRUNCATE)[^(]+?wcf".WCF_N."_acp_session(?:_data)?/si", $query)) {	
					try {
						$commandCount++;
						$result = WCF::getDB()->sendQuery($query);
					}
					catch (DatabaseException $e) {
						$errors['messages'][] = $e->getMessage();
						$errors['errorDescriptions'][] = $e->getErrorDesc();
	
						// exit import on first error
						if (!$ignoreErrors) {
							$file->seek($filesize);
							break; 
						}
					}
				}

				$query = '';
				if (!$extendedCommand) $isInsideCommand = false;
			}
			
			// check what comes up (comment, string  or command) 
			else if (!$isInsideString && !$isInsideComment && !$isInsideCommand) {
				// comment 
				if ($previousC.$c == '--') {
					$isInsideComment = $isSingleLineComment = true;
				}
				// multiline comment
				else if ($previousC.$c == '/*') {
					$isInsideComment = $isMultilineComment = true;
				}
				// search command start
				else if (preg_match("/[a-z]/i", $c)) {
					// get previous char to detect command start
					if (empty($previousC) && $file->tell() > 1) { 
						// get previous char
						$file->seek($file->tell() - 2);  
						$previousC = $file->getc();
						$file->seek($file->tell() + 1);
					}
					
					// TODO: find commands not only on start of line (command1; command2; ......)
					if (preg_match("/(\r|\n)/", $previousC) || empty($previousC)) {
						$commandOffset = $file->tell() - 1;
						$isInsideCommand = true;
						$query .= $c;
						
						// search for commands with extended syntax (INSERT/REPLACE)
						if (strtoupper($c) == 'I') {
							$command = 'I'.strtoupper($file->read(6));
							
							if ($command == 'INSERT ') {
								$query = 'INSERT ';	
								$isSpecialCommand = true;
								$checkExtendedCommand = true;
							}
							else $file->seek($file->tell() - 5);
						}
						else if (strtoupper($c) == 'R') {
							$command = 'R'.strtoupper($file->read(7));
							
							if ($command == 'REPLACE ') {
								$query = 'REPLACE ';	
								$isSpecialCommand = true;
								$checkExtendedCommand = true;
							}
							else $file->seek($file->tell() - 6);	
						}
						else if (strtoupper($c) == 'S' && empty($charset)) {
							$command = 'S'.strtoupper($file->read(9));
							
							if ($command == 'SET NAMES ') {
								while (false !== ($char = $file->getc()) && $char != ';') {
									$charset .= $char;	
								}
								$query = 'SET NAMES '.$charset.';';
								$execute = true;
							}
							else $file->seek($file->tell() - 9);	
						}
					}
					// No command: ignore character 
					else continue;
				}
			}
			// inside command (no special). build query and search command end
			else if ($isInsideCommand && !$isSpecialCommand) {
				if ($c == "'") {
					$query .= "'";
					$isInsideString = true;
				}
				// command end found. execute it
				else if ($c == ';') {
					$query .= ';';
					$execute = true;
					$isInsideCommand = false;

					// eof() doesn't work well so try to get the next char and seek one back is made to: 
					// enter the while loop on the end of file again when the last statement got to be executed.
					// if not on end, the seek back has to be done because the one char already read has to be caught in the next loop.
					//$file->getc();
					//$file->seek($file->tell() - 1);
				}
				else $query .= $c;
			}
			// check if special command got extended syntax
			else if ($isSpecialCommand && $checkExtendedCommand) {
				$query .= $c;
				$strOpen = $bracketClosed = $bracketOpen = $isValues = false;
				$previousChar = '';
				$command = $query;
					
				while (false !== ($char = $file->getc()) && ((time() - $loopStart < $loopTimeLimit) || $commandCount == 0)) {
					$command .= $char;
					
					// search for the VALUES keyword 
					if (!$isValues) {
						if (!$bracketOpen && $char != '(' && !$bracketClosed) continue;
						else if ($char == '(') {
							if (preg_match("/VALUES\s*\($/i", $command)) $isValues = true;
							$bracketOpen = true;
						}
						else if ($bracketOpen && $char == ')') {
							$bracketOpen = false;
							$bracketClosed = true;
						}
						else if ($bracketClosed && preg_match("/VALUES$/i", $command)) {
							$isValues = true;
							$bracketClosed = false;
						}
					}
					// check what comes behind the first VALUES bracket (, or ;)	
					else {
						if (!$strOpen && !$bracketOpen && $char != '(') continue;
						else if (!$strOpen && !$bracketOpen && $char == '(') $bracketOpen = true;
						else if (!$strOpen && !$bracketClosed) {
							if ($char == ")") $bracketClosed = true;
							else if ($char == "'") $strOpen = true;
						}
						else if ($strOpen) {
							if ($char == "'" && $previousChar != "\\") {
								if (false !== ($nextC = $file->getc()) && $nextC != "'") {
									$file->seek($file->tell() - 1);
									$strOpen = false;
								}
								else $command .= "'";						
							}
							else if ($char == "'") $strOpen = self::checkEscapedQuote($file);
						}
						else if ($bracketClosed) {
							if ($char == "," || $char == ";") {
								// extended INSERT/REPLACE found. execute it and store querystart (INSERT ... VALUES) for next insert/replace values.  
								if ($char == ",") {
									$isExtendedCommand = true;
									$query = preg_replace("/,$/", ';', $command);
									$extendedCommand = preg_replace("/(.*?VALUES).*/s", "$1 ", $command);
									$file->seek($file->tell() - 1);
								}
								// single INSERT/REPLACE found: execute it
								else if ($char == ";") {
									$isInsideCommand = $isExtendedCommand = $isSpecialCommand = false;
									$query = $command;
									$extendedCommand = '';

									// eof() doesn't work well so try to get the next char and seek one back is made to: 
									// enter the while loop on the end of file again when the last statement got to be executed.
									// if not on end, the seek back has to be done because the one char already read has to be caught in the next loop.
									// TODO: whats that? check it
									//$file->getc();
									//$file->seek($file->tell() - 1);
								}
								$execute = true;
								$commandOffset = $file->tell();
								$checkExtendedCommand = false;
							}
							break;
						}
						$previousChar = $char;
					}
				}
			}
			// find the next extended INSERT/REPLACE values 
			else if (!empty($extendedCommand)) {
				$strOpen = $bracketClosed = $bracketOpen = false;
				$previousChar = '';
				$query = '';
				// get one "value"-bracket and check whats behind (, or ;)			
				while (false !== ($char = $file->getc()) && (time() - $loopStart < $loopTimeLimit)) { 
					if ($bracketOpen) $query .= $char;
					
					if ($strOpen) {
						if ($char == "'" && $previousChar != "\\") {
							if (false !== ($nextC = $file->getc()) && $nextC != "'") {
								$file->seek($file->tell() - 1);
								$strOpen = false;
							}
							else $query .= "'";
						}
						else if ($char == "'") $strOpen = self::checkEscapedQuote($file);
					}
					else if ($char == "'") $strOpen = true;
					else if (!$bracketOpen && $char == '(') {
						$query .= '(';
						$bracketOpen = true;
					}
					else if ($bracketOpen) {
						if ($char == ")") {
							$bracketClosed = true;
							$bracketOpen = false;
						}
						else if ($char == "'") $strOpen = true;
					}
					// one value bracket complete. execute and check for more extended values (, or ;)
					else if ($bracketClosed) {
						$query = $extendedCommand.$query;
						$execute = true;
						if ($char == ";") {
							$isExtendedCommand = $isInsideCommand = $isSpecialCommand = false;
							$extendedCommand = '';
						}
						else if ($char == ",") {
							$file->seek($file->tell() - 2);
							$commandOffset = $file->tell();
						}
						break;
					}
					$previousChar = $char;
				}
			}
			$previousC = $c;
		}// end while

		// time limit reached and command can't be executed in this step. jump back to command start and reload 
		if ($isInsideCommand) {
			if ($ignoreErrors || count($errors['messages']) == 0) $file->seek($commandOffset);
			if (!$isExtendedCommand) $extendedCommand = '';
		}
		// not inside command and not eof. go one char back and reload
		else if (false !== ($c = $file->getc())) {
			if ($ignoreErrors || count($errors['messages']) == 0) {
				$file->seek($file->tell() - 2);
			}		
		}
		// end of file
		else $file->seek($filesize);

		return array(
			'charset' => $charset,
			'offset' => $file->tell(),
			'commandCount' => $commandCount,
			'errors' => $errors,
			'extendedCommand' => $extendedCommand,
			'done' => $file->tell() - $offset + $bomOffset
		);
	}
	
	/**
	 *  
	 */
	public static function getTableStates($tables) {
		$tablesInformation = WCF::getDB()->getTableStatus();

		// get table infos (rowcount etc.)
		foreach ($tablesInformation as $key => $tableInfo) {
			if (!in_array($tableInfo['Name'], $tables)) {
				unset($tablesInformation[$key]);
			}
		}
		return $tablesInformation;
	}
	
	/**
	 * Function to check if an ' with a \ in front is an escaped quote or not.
	 * E.x. \\' is an escaped slash but \\\' is an escaped slash with an escaped singlequote.
	 * If the backslashcount in front of ' is even the quote is the string termination. 
	 */
	protected static function checkEscapedQuote($file) {
		$stringEnd = false;
		$tmpPos = $file->tell();
		$backslashCount = 0;
		$file->seek($tmpPos - 2); 		
		while (($c = $file->getc()) && $c == "\\") {
			$backslashCount++;
			$file->seek($file->tell() - 2);
		}
		
		$file->seek($tmpPos);
		if ($backslashCount % 2 == 0) return false;
		else return true;
	}
}
?>